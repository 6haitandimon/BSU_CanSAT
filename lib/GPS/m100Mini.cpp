#include "m100Mini.h"GPS::M100Mini* GPS::M100Mini::instance = nullptr;void GPS::M100Mini::GpsIrqHandler() {  while (uart_is_readable(this->_uart)) {    uint8_t data = uart_getc(this->_uart);    gps_rx_buffer[gps_rx_index++] = data;    if (gps_rx_index >= GPS_PACKET_SIZE) {      memcpy((void*)gps_packet, gps_rx_buffer, GPS_PACKET_SIZE);      gps_packet_ready = true;      gps_rx_index = 0;      return;    }  }}GPS::M100Mini::M100Mini(uart_inst_t *uart, uint8_t uartTXPin, uint8_t uartRXPin,                        uint32_t uartBauRate) : _uart(uart), _uartRXPin(uartRXPin), _uartTXPin(uartTXPin), _uartBauRate(uartBauRate) {  instance = this;}void GPS::M100Mini::m100Mini_Init(){  uart_init(this->_uart, this->_uartBauRate);  gpio_set_function(this->_uartRXPin, GPIO_FUNC_UART);  gpio_set_function(this->_uartTXPin, GPIO_FUNC_UART);  uart_set_hw_flow(this->_uart, false, false);  uart_set_format(this->_uart, 8, 1, UART_PARITY_NONE);  uart_set_fifo_enabled(this->_uart, false);  irq_set_exclusive_handler(UART1_IRQ, StaticGpsIrqHandler);  irq_set_enabled(UART1_IRQ, true);  uart_set_irq_enables(this->_uart, true, false);}bool GPS::M100Mini::GetGPS(GPS::NAV_POSLLH *gpsStruct){  if (gps_packet_ready) {    gps_packet_ready = false;    memcpy(gpsStruct, gps_packet, sizeof(struct NAV_POSLLH));    if (!CalculateChecksum(gps_packet, GPS_PACKET_SIZE)) {      return false;    }    return true;  }  return false;}bool GPS::M100Mini::CalculateChecksum(const uint8_t *data, size_t len) {  uint8_t CK_A = 0, CK_B = 0;  for (size_t i = 2; i < len - 2; ++i) {    CK_A += data[i];    CK_B += CK_A;  }  return (CK_A == data[len - 2] && CK_B == data[len - 1]);}void GPS::M100Mini::StaticGpsIrqHandler() {  instance->GpsIrqHandler();}